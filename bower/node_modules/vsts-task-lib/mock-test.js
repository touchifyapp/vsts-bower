"use strict";
var cp = require('child_process');
var os = require('os');
var cmdm = require('./taskcommand');
var shelljs = require('shelljs');
var COMMAND_TAG = '[command]';
var COMMAND_LENGTH = COMMAND_TAG.length;
var MockTestRunner = (function () {
    function MockTestRunner(testPath) {
        this._testPath = testPath;
    }
    Object.defineProperty(MockTestRunner.prototype, "failed", {
        get: function () {
            return !this.succeeded;
        },
        enumerable: true,
        configurable: true
    });
    MockTestRunner.prototype.ran = function (cmdline) {
        return this.cmdlines.hasOwnProperty(cmdline.trim());
    };
    MockTestRunner.prototype.createdErrorIssue = function (message) {
        return this.errorIssues.indexOf(message.trim()) >= 0;
    };
    MockTestRunner.prototype.createdWarningIssue = function (message) {
        return this.warningIssues.indexOf(message.trim()) >= 0;
    };
    MockTestRunner.prototype.stdOutContained = function (message) {
        return this.stdout && this.stdout.indexOf(message) > 0;
    };
    MockTestRunner.prototype.stdErrContained = function (message) {
        return this.stderr && this.stderr.indexOf(message) > 0;
    };
    MockTestRunner.prototype.run = function () {
        var _this = this;
        this.cmdlines = {};
        this.invokedToolCount = 0;
        this.succeeded = true;
        this.errorIssues = [];
        this.warningIssues = [];
        // we use node in the path.
        // if you want to test with a specific node, ensure it's in the path
        var nodePath = shelljs.which('node');
        if (!nodePath) {
            console.error('Could not find node in path');
            return;
        }
        var spawn = cp.spawnSync(nodePath, [this._testPath]);
        if (spawn.error) {
            console.error('Running test failed');
            console.error(spawn.error.message);
            return;
        }
        this.stdout = spawn.stdout.toString();
        this.stderr = spawn.stderr.toString();
        var lines = this.stdout.split(os.EOL);
        lines.forEach(function (line) {
            if (process.env['TASK_TEST_TRACE']) {
                console.log(line);
            }
            var ci = line.indexOf('##vso');
            var cmi = line.indexOf(COMMAND_TAG);
            if (ci >= 0) {
                var cmd = cmdm.commandFromString(line.substring(ci));
                if (cmd.command === 'task.complete' && cmd.properties['result'] === 'Failed') {
                    _this.succeeded = false;
                }
                if (cmd.command === 'task.issue' && cmd.properties['type'] === 'error') {
                    _this.errorIssues.push(cmd.message.trim());
                }
                if (cmd.command === 'task.issue' && cmd.properties['type'] === 'warning') {
                    _this.warningIssues.push(cmd.message.trim());
                }
            }
            else if (cmi == 0 && line.length > COMMAND_LENGTH) {
                var cmdline = line.substr(COMMAND_LENGTH).trim();
                _this.cmdlines[cmdline] = true;
                _this.invokedToolCount++;
            }
        });
        if (this.stderr && process.env['TASK_TEST_TRACE']) {
            console.log('STDERR: ' + this.stderr);
        }
    };
    return MockTestRunner;
}());
exports.MockTestRunner = MockTestRunner;
